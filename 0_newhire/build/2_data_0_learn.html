<h1 id="nhcc102-intro-to-data-modelling">NHCC102: Intro To Data Modelling</h1>
<hr />
<h1 id="overview">Overview</h1>
<p>Data modeling is the process of designing and organizing data in a way that reflects the real-world relationships and constraints within a system. Data models are used to represent the structure and organization of data, and to ensure that the data is stored and accessed in a consistent and efficient manner. There are many different considerations that can weigh on data modeling, including the following:</p>
<ul>
<li><p><strong>Data structure</strong>: One of the most important considerations in data modeling is the structure of the data itself. This includes the types of data that are being stored (e.g., text, numbers, dates), the format of the data (e.g., fixed-length or variable-length), and the relationships between different pieces of data (e.g., one-to-one, one-to-many, many-to-many).</p></li>
<li><p><strong>Performance</strong>: Another important consideration in data modeling is performance. Data models should be designed in a way that minimizes the amount of time and resources needed to store, retrieve, and manipulate data. This might involve choosing data structures that are optimized for specific types of queries, or partitioning data in a way that reduces the amount of data that needs to be processed at any given time.</p></li>
<li><p><strong>Scalability</strong>: Data models should also be designed to be scalable, so that they can handle an increasing amount of data over time without degrading in performance. This might involve choosing data structures that are efficient for inserting and deleting data, or partitioning data in a way that allows it to be distributed across multiple servers.</p></li>
<li><p><strong>Maintainability</strong>: Data models should also be designed to be maintainable, so that they can be easily modified and updated as the needs of the system change. This might involve choosing data structures that are flexible and adaptable, or using design patterns that facilitate the modification and evolution of the data model.</p></li>
</ul>
<hr />
<h2 id="design-patterns">Design Patterns</h2>
<p>There are many different design patterns that can be used in data modeling, depending on the specific needs and goals of the system. Some common design patterns that are used in data modeling include the following:</p>
<ul>
<li><p><strong>Entity-relationship (ER) model</strong>: The ER model is a graphical representation of the data and relationships within a system. It is often used to model the structure of a database, and it is particularly useful for representing one-to-one, one-to-many, and many-to-many relationships.</p></li>
<li><p><strong>Object-oriented model</strong>: The object-oriented model is a data model that is based on the concept of “objects,” which are self-contained units that represent real-world entities and the relationships between them. This model is often used to model complex, dynamic systems, and it is particularly useful for representing inheritance and polymorphism.</p></li>
<li><p><strong>Relational model</strong>: The relational model is a data model that is based on the concept of “relations,” which are tables that represent the data and relationships within a system. This model is based on the idea of organizing data into rows and columns, and it is particularly useful for representing complex relationships between data.</p></li>
<li><p><strong>NoSQL model</strong>: The NoSQL (Not Only SQL) model is a data model that is designed for storing and manipulating large amounts of data that is not well-suited to the relational model. NoSQL models include a variety of different data structures, such as key-value stores, document databases, and graph databases, and they are often used for handling large volumes of data that need to be stored and accessed in real-time.</p></li>
</ul>
<p>Ultimately, the most appropriate design patterns for data modeling will depend on the specific needs and goals of the system, as well as the resources and constraints that are available. It is important to carefully consider the trade-offs between different design patterns and choose the one that is most appropriate for the given situation.</p>
<hr />
<h2 id="rdbms-overview">RDBMS Overview</h2>
<p>A relational database management system (RDBMS) is a type of database management system that stores data in a structured, organized way, using tables and relationships between those tables. Here is a crash course on some of the key concepts and features of RDBMS schemas:</p>
<ul>
<li><p><strong>Schema</strong>: A schema is the overall structure and organization of a database. It includes the tables, columns, data types, and relationships between the tables.</p></li>
<li><p><strong>Data types</strong>: Data types specify the kind of data that can be stored in a column, such as text, numbers, or dates. Different RDBMSs support different data types, and it is important to choose the appropriate data type for each column based on the kind of data that will be stored.</p></li>
<li><p><strong>Triggers</strong>: Triggers are pieces of code that are automatically executed by the database in response to certain events, such as the insertion of a new row into a table. Triggers can be used to enforce constraints, to update other tables, or to perform other actions based on the data in the database.</p></li>
<li><p><strong>Indexes</strong>: Indexes are used to speed up the search process in a database. They are created on specific columns in a table, and they allow the database to quickly find rows that match a particular value or range of values.</p></li>
<li><p><strong>Engines</strong>: An RDBMS engine is the software component that is responsible for storing and retrieving data from the database. Different RDBMSs use different engines, and the choice of engine can have a significant impact on the performance and capabilities of the database.</p></li>
</ul>
<p>These are just a few examples of the key concepts and features that are important in RDBMS schemas. There are many other aspects of RDBMS design and administration that are important to understand in order to effectively manage and manipulate data in a relational database.</p>
<hr />
<h2 id="schemas">Schemas</h2>
<p>A schema is the overall structure and organization of a database. It includes the tables, columns, data types, and relationships between the tables. A schema defines how the data is organized and how it can be accessed and manipulated.</p>
<p>In a relational database, a schema is defined using a special type of language called a data definition language (DDL). The DDL is used to create and modify the structure of the database, including the tables, columns, and other objects that make up the schema.</p>
<p>Here are a few more details about schemas and their components:</p>
<ul>
<li><p><strong>Tables</strong>: A table is a structured collection of data that is organized into rows and columns. Each row represents a unique record, and each column represents a specific piece of data. Tables are typically used to store data about a specific entity, such as employees, products, or orders.</p></li>
<li><p><strong>Columns</strong>: A column is a vertical slice of a table that represents a specific piece of data. Each column has a name and a data type, and each row in the table has a value for that column. Columns can be used to store data of different types, such as text, numbers, or dates.</p></li>
<li><strong>Data types</strong>: Data types specify the kind of data that can be stored in a column. Different RDBMSs support different data types, and it is important to choose the appropriate data type for each column based on the kind of data that will be stored. Some common data types include:
<ul>
<li>INTEGER: A whole number.</li>
<li>REAL: A decimal number.</li>
<li>TEXT: A string of characters.</li>
<li>DATE: A date and time.</li>
</ul></li>
<li><strong>Relationships</strong>: Relationships are the connections between different tables in a database. There are several types of relationships that can be defined in a schema, including:
<ul>
<li>One-to-one: A one-to-one relationship exists when each row in one table is related to exactly one row in another table.</li>
<li>One-to-many: A one-to-many relationship exists when one row in a table is related to many rows in another table.</li>
<li>Many-to-many: A many-to-many relationship exists when many rows in one table are related to many rows in another table.</li>
</ul></li>
<li><p>Relationships are defined using <strong>foreign keys</strong>, which are columns that contain the primary key of a related table. By establishing relationships between tables, it is possible to link and retrieve data from multiple tables in a single query.</p></li>
</ul>
<p>Overall, the schema of a database is a critical aspect of its design and organization, and it is important to carefully plan and design the schema to ensure that the data is stored in an efficient and logical way.</p>
<hr />
<h2 id="sql">SQL</h2>
<p>SQL (Structured Query Language) is a programming language that is used to manage and manipulate data stored in relational databases. Here is a crash course on some of the basic SQL commands that are used to perform CRUD (create, read, update, delete) operations on a database:</p>
<ul>
<li><strong>CREATE</strong>: The CREATE command is used to create new tables, views, or other objects in the database. For example, the following SQL statement creates a new table called “employees” with three columns:</li>
</ul>
<pre><code>    CREATE TABLE employees (
        employee_id INTEGER PRIMARY KEY,
        employee_name TEXT NOT NULL,
        employee_salary REAL
    );</code></pre>
<ul>
<li><strong>INSERT</strong>: The INSERT command is used to add new rows of data to a table. For example, the following SQL statement inserts a new row into the “employees” table:</li>
</ul>
<pre><code>    INSERT INTO employees (employee_id, employee_name, employee_salary)
    VALUES (1, &#39;John Smith&#39;, 50000);</code></pre>
<ul>
<li><strong>SELECT</strong>: The SELECT command is used to retrieve data from a table. For example, the following SQL statement retrieves all rows from the “employees” table:</li>
</ul>
<pre><code>    SELECT * FROM employees;</code></pre>
<ul>
<li><strong>UPDATE</strong>: The UPDATE command is used to modify existing rows of data in a table. For example, the following SQL statement updates the employee salary for the employee with ID 1:</li>
</ul>
<pre><code>    UPDATE employees
    SET employee_salary = 55000
    WHERE employee_id = 1;</code></pre>
<ul>
<li><strong>DELETE</strong>: The DELETE command is used to delete rows of data from a table. For example, the following SQL statement deletes the employee with ID 1 from the “employees” table:</li>
</ul>
<pre><code>    DELETE FROM employees
    WHERE employee_id = 1;</code></pre>
<p>These are just a few examples of the basic SQL commands that are used to perform CRUD operations on a database. There are many other SQL commands and features that can be used to manipulate and manage data in more complex ways.</p>
<hr />
<h2 id="normalization">Normalization</h2>
<p>Normalization is a process of organizing a database in a way that reduces redundancy and dependency, and that makes it more flexible and easier to maintain. The goal of normalization is to decompose a large, complex database schema into smaller, more modular pieces, and to organize the data in a way that minimizes redundancy and reduces the risk of data inconsistencies.</p>
<p>There are several different normal forms that can be used to normalize a database schema, ranging from the first normal form (1NF) to the fifth normal form (5NF). Each normal form builds on the previous one, and the higher the normal form, the more normalized the schema is. Here is a brief overview of the different normal forms:</p>
<ul>
<li><strong>First normal form (1NF)</strong>: A schema is in 1NF if it meets the following criteria:
<ul>
<li>Each column contains a single value.</li>
<li>There are no repeating groups of columns.</li>
</ul></li>
<li><strong>Second normal form (2NF)</strong>: A schema is in 2NF if it meets the following criteria:
<ul>
<li>It is in 1NF.</li>
<li>It has no partial dependencies. (A partial dependency is a situation where a non-key attribute is functionally dependent on only a part of the primary key.)</li>
</ul></li>
<li><strong>Third normal form (3NF)</strong>: A schema is in 3NF if it meets the following criteria:
<ul>
<li>It is in 2NF.</li>
<li>It has no transitive dependencies. (A transitive dependency is a relationship between three attributes, where the value of one attribute determines the value of a second attribute, which in turn determines the value of a third attribute.)</li>
</ul></li>
<li><strong>Fourth normal form (4NF)</strong>: A schema is in 4NF if it meets the following criteria:
<ul>
<li>It is in 3NF.</li>
<li>It has no multi-valued dependencies. (A multi-valued dependency is a situation where a non-key attribute is functionally dependent on multiple other non-key attributes.)</li>
</ul></li>
<li><strong>Fifth normal form (5NF)</strong>: A schema is in 5NF if it meets the following criteria:
<ul>
<li>It is in 4NF.</li>
<li>It has no join dependencies. (A join dependency is a situation where the schema can be decomposed into two or more smaller schemas, and the original schema can be reconstructed by performing a join operation on those smaller schemas.)</li>
</ul></li>
</ul>
<p>There are many other concepts and techniques that are related to normalization, and it is important to understand these concepts in order to effectively design and maintain a normalized database schema.</p>
<hr />
<h2 id="migrating-between-schemas">Migrating Between Schemas</h2>
<p>Assuming the initial schema is a mess, the process of normalizing the schema might involve the following steps:</p>
<ul>
<li><p><strong>Identify the entities (tables) in the schema</strong>: The first step in normalization is to identify the entities (tables) in the schema, and to determine the relationships between those entities. This might involve reviewing the existing schema, analyzing the data that is being stored, and identifying any patterns or dependencies that exist between different pieces of data.</p></li>
<li><p><strong>Identify functional dependencies</strong>: The next step is to identify the functional dependencies within the schema. A functional dependency is a relationship between two attributes (columns) in a table, where the value of one attribute determines the value of the other attribute. For example, in a table that stores information about employees, the employee ID might be functionally dependent on the employee name, because the employee ID is uniquely determined by the employee name.</p></li>
<li><p><strong>Eliminate transitive dependencies</strong>: Once the functional dependencies have been identified, the next step is to eliminate any transitive dependencies that might exist within the schema. A transitive dependency is a relationship between three attributes, where the value of one attribute determines the value of a second attribute, which in turn determines the value of a third attribute. For example, if a table stores information about employees, and the employee department is functionally dependent on the employee ID, and the employee ID is functionally dependent on the employee name, then there is a transitive dependency between the employee name, employee ID, and employee department.</p></li>
<li><p><strong>Eliminate partial dependencies</strong>: The next step is to eliminate any partial dependencies that might exist within the schema. A partial dependency is a situation where a non-key attribute is functionally dependent on only a part of the primary key. For example, if a table stores information about employees, and the employee salary is functionally dependent on the employee ID, but the employee ID is a composite primary key that consists of both the employee name and the employee department, then there is a partial dependency between the employee salary and the employee name.</p></li>
<li><p><strong>Normalize the schema</strong>: Once all transitive and partial dependencies have been eliminated, the schema can be normalized into a series of smaller, more modular tables. This might involve breaking down large tables into smaller ones, or creating new tables to represent relationships between different entities.</p></li>
<li><p><strong>Script migrations</strong>: Once the schema has been normalized, the next step is to script the migrations that will be needed to move the data from the legacy schema to the refactored one. This might involve creating SQL scripts to alter the structure of the tables, to move data from one table to another, or to update the data in some way. It is important to carefully plan and test the migrations to ensure that they are performed correctly and that the data is not lost or corrupted during the process.</p></li>
</ul>
<p>Normalization is an important process in database design, as it helps to ensure that the data is stored in a way that is efficient, flexible, and easy to maintain. By following these steps, it is possible to refactor a legacy schema into a normalized form that is better suited to the needs of the system.</p>
<hr />
<h2 id="performance-sleuthing-optimizations">Performance Sleuthing &amp; Optimizations</h2>
<p>There are many different factors that can contribute to slow performance in a database query, and identifying the specific cause of the bottleneck can be a complex and time-consuming process. Here are a few common performance bottlenecks that can be found in queries:</p>
<ul>
<li><p><strong>Inefficient query design</strong>: One of the most common causes of slow performance in a database query is an inefficient query design. This might involve using inefficient algorithms, using unnecessarily complex queries, or failing to take advantage of available indexes.</p></li>
<li><p><strong>Lack of indexes</strong>: Indexes are used to speed up the search process in a database, and a lack of appropriate indexes can significantly slow down the performance of a query. It is important to carefully analyze the data and the queries being run against it, and to create indexes as needed to support the most common and important queries.</p></li>
<li><p><strong>Fragmented indexes</strong>: Over time, indexes can become fragmented, which means that the data is scattered across multiple pages on the disk. This can slow down the performance of a query, as the database engine has to read multiple pages in order to retrieve the data.</p></li>
<li><p><strong>Insufficient memory</strong>: If the database server does not have enough memory to store the data and indexes needed to support the query, it might have to read data from disk, which can significantly slow down the performance of the query.</p></li>
<li><p><strong>Contention for resources</strong>: If the database server is heavily loaded and there are many queries and transactions competing for the same resources, this can lead to contention and slow down the performance of individual queries.</p></li>
</ul>
<p>There are many other factors that can contribute to slow performance in a database query, and identifying the specific cause of the bottleneck will often require careful analysis and experimentation. It is important to carefully monitor the performance of the database and to continually tune and optimize the queries and the schema to ensure that the system is performing at its best.</p>
